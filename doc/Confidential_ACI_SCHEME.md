# Confidential ACI scheme to support verification that a container group is genuine

Confidential ACI uses [AMD SEV-SNP features](https://www.amd.com/en/support/tech-docs/sev-secure-nested-paging-firmware-abi-specification) to ensure the VM hosting running containers is secure against threats from the host operating system. The host starts a Utility VM running a minimalist Linux in SNP mode for this purpose. 

It is essential to check that sensitive workloads are indeed running in SNP VMs. This is done by obtaining an attestation report signed by the AMD hardware and passing that to a relying party to verify. You can also verify the attestation report manually.


Thus, a container must provide evidence to the relying party such that it can decide to release sensitive information to the container.

The evidence comprises the attestation report itself and three artefacts used to check it. These are:
- Certificates issued by AMD to prove the particular CPU in the physical host is genuine and to verity the signed attestation report was generated by that CPU.
- A [COSE_Sign1](https://datatracker.ietf.org/doc/html/rfc9052) document signed by the Microsoft team which is responsible for the SNP VM image containing the expected hardware measurement of the SNP Utility VM and a SVN (Security Version Number) 
- The [confidential computing enforcement policy](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-confidential-overview#confidential-computing-enforcement-policies), also known as security policy supplied to the container runtime within the SNP Utility VM by the ACI infrastructure. This is the security policy provided by the customer to control what can be run within the VM, for example, which containers, environment variables, command lines and so forth.

These artefacts are provided as base64 encoded files in each container’s filesystem. The path to these files is generated to avoid colliding with existing files and made available via an environment variable `UVM_SECURITY_CONTEXT_DIR` (typically `/security-context-*`). Under that path are three files:
- host-amd-cert-base64
- reference-info-base64
- security-policy-base64

## host-amd-cert-base64

These are the AMD platform certificates, as per Trusted Hardware Identity Management Document - https://learn.microsoft.com/en-us/azure/security/fundamentals/trusted-hardware-identity-management#definitions, encoded to base64. As a Go data structure:

```go
// format of the JSON provided to the UVM by hcsshim. Comes from the THIM endpoint
// and is a base64 encoded JSON string
type THIMCerts struct {
    VcekCert         string `json:"vcekCert"`
    Tcbm             string `json:"tcbm"`
    CertificateChain string `json:"certificateChain"`
    CacheControl     string `json:"cacheControl"`
}
```

Example code using the struct can be found here:

https://github.com/microsoft/confidential-sidecar-containers/blob/main/pkg/common/info.go

The following is an example of decoded JSON object:

```json
{
    "vcekCert": "<PEM certificate>",
    "tcbm": "7308000000000003",
    "certificateChain": "<PEM certificate chain>",
    "cacheControl": "86400"
}
```

The difference between (Trusted Computing Base) TCB and `tcbm` is TODO.
`cacheControl` is TODO.

## reference-info-base64

The COSE_Sign1  envelope has a JSON object as payload. It contains the SVN of Confidential ACI as x-ms-sevsnpvm-guestsvn and hex encoded launch time measurement of UVM as x-ms-sevsnpvm-launchmeasurement.

The latest SNV can be found at TODO.

The measurement the same as MEASUREMENT of attestation report in Table 21 of [SEV Secure Nested Paging Firmware ABI Specification](https://www.amd.com/en/support/tech-docs/sev-secure-nested-paging-firmware-abi-specification).

There might be more fields in the JSON in future.

The following is an example payload:
```json
{
  "x-ms-sevsnpvm-guestsvn": "100",
  "x-ms-sevsnpvm-launchmeasurement": "03fea02823189b25d0623a5c81f97c8ba4d2fbc48c914a55ce525f90454ddcec303743dac2fc013f0846912d1412f6df"
}
```

The COSE_Sign1 envelop can be unpacked using [COSE_Sign1 go](https://pkg.go.dev/github.com/Microsoft/COSE_Sign1 go) package in Go.

It can be checked if it is properly signed by Microsoft by validating [did:x509](https://github.com/microsoft/did-x509/blob/main/specification.md) string.
[didx509go](https://pkg.go.dev/github.com/Microsoft/didx509go) package can be used in Go for the validation.

```go
    unpacked, err := cosesign1.UnpackAndValidateCOSE1CertChain(uvmEndorsements)
    if err != nil {
        log.Fatalf("Failed to unpack COSE_SIGN1 document: %s", err.Error())
    }

    // Resolve returns a did doc that we don't need
    // we only care if there was an error or not
    _, err = didx509resolver.Resolve(unpacked.ChainPem, unpacked.Issuer, true)
    if err != nil {
        log.Fatalf("Failed to resolve did:x509 string: %s", err.Error())
    }
```

In C++, [t_cose](https://github.com/laurencelundblade/t_cose) and [didx509cpp](https://github.com/microsoft/didx509cpp) are available to handle COSE_Sign1 and did:x509 respectively.

## security-policy-base64

The [Rego](https://www.openpolicyagent.org/docs/latest/policy-language/) security policy is written in  by users or generated by [Microsoft Azure CLI 'confcom' Extension](https://github.com/Azure/azure-cli-extensions/blob/main/src/confcom/azext_confcom/README.md). It is provided to the UVM at startup, and its SHA256 hash is used as HOST_DATA of attestation report. The following is an example:

```
package policy

import future.keywords.every
import future.keywords.in

api_version := "0.10.0"
framework_version := "0.2.3"

fragments := […]

containers := […]

allow_properties_access := false
allow_dump_stacks := false
allow_runtime_logging := false
allow_environment_variable_dropping := true
allow_unencrypted_scratch := false
allow_capability_dropping := true

mount_device := data.framework.mount_device
unmount_device := data.framework.unmount_device
mount_overlay := data.framework.mount_overlay
unmount_overlay := data.framework.unmount_overlay
create_container := data.framework.create_container
exec_in_container := data.framework.exec_in_container
exec_external := data.framework.exec_external
shutdown_container := data.framework.shutdown_container
signal_container_process := data.framework.signal_container_process
plan9_mount := data.framework.plan9_mount
plan9_unmount := data.framework.plan9_unmount
get_properties := data.framework.get_properties
dump_stacks := data.framework.dump_stacks
runtime_logging := data.framework.runtime_logging
load_fragment := data.framework.load_fragment
scratch_mount := data.framework.scratch_mount
scratch_unmount := data.framework.scratch_unmount

reason := {"errors": data.framework.errors}
```
