# Confidential ACI scheme to support verification that a container group is genuine

Confidential ACI uses [AMD SEV-SNP features](https://www.amd.com/en/support/tech-docs/sev-secure-nested-paging-firmware-abi-specification) to ensure the VM hosting running containers is secure against threats from the host operating system. The host starts a Utility VM (UVM) running a minimalist Linux in SNP mode for this purpose. 

It is essential to check that sensitive workloads are indeed running in SNP VMs. This is done by obtaining an attestation report signed by the AMD hardware and passing that to a relying party to verify. You can also verify the attestation report manually.


Thus, a container must provide evidence to the relying party such that it can decide to release sensitive information to the container.

The evidence comprises the attestation report itself and three artefacts used to check it. These are:
- Certificates issued by AMD to prove the particular CPU in the physical host is genuine and to verify the signed attestation report was generated by that CPU.
- A [COSE_Sign1](https://datatracker.ietf.org/doc/html/rfc9052) document signed by the Microsoft team which is responsible for the SNP VM image containing the expected hardware measurement of the SNP Utility VM and a SVN (Security Version Number).
- The [confidential computing enforcement policy](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-confidential-overview#confidential-computing-enforcement-policies), also known as security policy, supplied to the container runtime within the SNP Utility VM by the ACI infrastructure. This is the security policy provided by the customer to control what can be run within the VM, for example, which containers, environment variables, command lines and so forth.

These artefacts are provided as base64 encoded files in each containerâ€™s filesystem. The path to these files is generated to avoid colliding with existing files and made available via an environment variable `UVM_SECURITY_CONTEXT_DIR` (typically `/security-context-*`). Under that path are three files:
- host-amd-cert-base64
- reference-info-base64
- security-policy-base64

## host-amd-cert-base64

These are the AMD platform certificates, as per Trusted Hardware Identity Management Document - https://learn.microsoft.com/en-us/azure/security/fundamentals/trusted-hardware-identity-management#definitions, inlined in a JSON document encoded to base64. As JSON Schema:

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "vcekCert": {
      "type": "string"
    },
    "tcbm": {
      "type": "string",
      "pattern": "^[0-9A-F]+$"
    },
    "certificateChain": {
      "type": "string"
    },
    "cacheControl": {
      "type": "string"
    }
  },
  "required": [
    "vcekCert",
    "tcbm",
    "certificateChain",
    "cacheControl"
  ]
}
```

`tcbm` is CURRENT_TCB in Table 21 of [SEV Secure Nested Paging Firmware ABI Specification](https://www.amd.com/en/support/tech-docs/sev-secure-nested-paging-firmware-abi-specification).
`cacheControl` is an implementation detail.

The following is an example of decoded JSON object:

```json
{
    "vcekCert": "<PEM certificate>",
    "tcbm": "7308000000000003",
    "certificateChain": "<PEM certificate chain>",
    "cacheControl": "86400"
}
```

Example code that handles the JSON object can be found here:

https://github.com/microsoft/confidential-sidecar-containers/blob/main/pkg/common/info.go

## reference-info-base64

This is a base64 encoded COSE_Sign1 document.

COSE_Sign1 envelopes are signed wrappers for arbitary data. See https://datatracker.ietf.org/doc/html/rfc8152. There is a header which contains the `iss` (issuer) and `feed` fields that must match Confidential ACI's signing identity and the certificate chain used to sign the whole bundle.

The COSE_Sign1 envelope has a JSON object as payload. The following is the JSON Schema:

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "x-ms-sevsnpvm-guestsvn": {
      "type": "string",
      "pattern": "^[0-9]+$"
    },
    "x-ms-sevsnpvm-guestsvn-int": {
      "type": "integer"
    },
    "x-ms-sevsnpvm-launchmeasurement": {
      "type": "string",
      "pattern": "^[0-9a-f]+$"
    }
  },
  "required": [
    "x-ms-sevsnpvm-guestsvn",
    "x-ms-sevsnpvm-guestsvn-int",
    "x-ms-sevsnpvm-launchmeasurement"
  ]
}
```

It contains the SVN of Confidential ACI as `x-ms-sevsnpvm-guestsvn` and hex encoded launch time measurement of UVM as `x-ms-sevsnpvm-launchmeasurement`. As of October 20th 2025 there is an addition field `x-ms-sevsnpvm-guestsvn-int` which is a JSON integer field, rather than a JSON string field.

The production SVN starts from 100, the current (as of October 20th 2025) SVN is 103. This is the minimum value, only when all production instances are updated will this document be updated.

This is the SVN of the UVM, ie the kernel and userland including the guest agent (GCS). This is NOT the AMD SEV-SNP guestsvn that is located in the ID BLOCK used to launch the UVM and that is reflected in attestation reports.

This is due to the mechanisms used to sign the reference

There may be more fields in the JSON in future.

The following is an example payload:
```json
{
  "x-ms-sevsnpvm-launchmeasurement": "d0c9e2be22046e60779be88868cff64c2aa22047c15d3127ba495cee3fbc2854c5633f9da2096e6c64ae2b69bbff8082",
  "x-ms-sevsnpvm-guestsvn": "103",
  "x-ms-sevsnpvm-guestsvn-int": 103
}
```

The field `x-ms-sevsnpvm-launchmeasurement` must match the launch measurement provided by the field MEASUREMENT of attestation report in Table 21 of [SEV Secure Nested Paging Firmware ABI Specification](https://www.amd.com/en/support/tech-docs/sev-secure-nested-paging-firmware-abi-specification). C code to obtain such a report can be found at https://github.com/microsoft/confidential-sidecar-containers/tree/main/tools/get-snp-report. Note that there are currently two versions - get-snp-report5.c for Linux Kernel version 5.15.* and get-snp-report6.c for kernels from 6.1 onwards.


To validate the COSE_Sign1 envelop you need to unpack it and check the `iss` and `feed` protected headers are as expected.
`iss` is a [did:x509](https://github.com/microsoft/did-x509/blob/main/specification.md) string and it can be used to check if it is properly signed by Microsoft.
Confidential ACI Utility VMs are signed with a certificate chain which matches the DID:x509 `did:x509:0:sha256:I__iuL25oXEVFdTP_aBLx_eT1RPHbCQ_ECBQfYZpt9s::eku:1.3.6.1.4.1.311.76.59.1.2`.
`feed` is a string `ContainerPlat-AMD-UVM`. These are stable identifiers, fixed for the lifetime of the root certificate which is more than 10 years.
The DID:x509 string contains a hash of the root certificate and the eku (extended key usage) of the leaf certificate. COSE_Sign1 validation libraries (such as https://github.com/microsoft/cosesign1go, https://github.com/microsoft/cosesign1go/tree/main/cmd/sign1util#check) can be used to confirm that the document was signed by the expected issuing authority. In this case that is the team within Microsoft responsible for producing the UVM image (see https://github.com/microsoft/hcsshim).

These are examples that validate COSE_Sign1 envelope:
- https://github.com/microsoft/hcsshim/blob/36359c002b0df048ea65a4c7fd27d5a4ec1310c5/internal/guest/runtime/hcsv2/uvm.go#L182
- https://github.com/microsoft/CCF/blob/65fe3d896e479d931c2d892bb3fe65aee47df605/src/node/uvm_endorsements.h#L268

The first is the code that validates the similar security policy fragments, the second is code that validates these UVM reference information documents.

In Go, [cosesign1go](https://pkg.go.dev/github.com/Microsoft/cosesign1go) and [didx509go](https://pkg.go.dev/github.com/Microsoft/didx509go) are available to handle COSE_Sign1 and did:x509 respectively.
In C++, [t_cose](https://github.com/laurencelundblade/t_cose) and [didx509cpp](https://github.com/microsoft/didx509cpp) are available.

Note that the certificate chain expiry date applies to the signing time and not the use time. A particular UVM can still be in use after the signing certificate expires. When validating the either a fragment or a uvm endorsement the current time is not used.

## security-policy-base64

The [Rego](https://www.openpolicyagent.org/docs/latest/policy-language/) security policy is written by users or generated by [Microsoft Azure CLI 'confcom' Extension](https://github.com/Azure/azure-cli-extensions/blob/main/src/confcom/azext_confcom/README.md). It is provided to the UVM at startup via the ACI configuration, and its SHA256 hash is used as HOST_DATA of attestation report. The following is an example:

https://github.com/Azure/azure-cli-extensions/blob/5362377ed1a674285dee0c3e4b517af8fbd1b26b/src/confcom/samples/sample-policy-output.rego


# Relying party logic

It is essential that a container must not be given access to sensitive data before it is established that it is genuine. The container itself cannot do that as an attacker in charge of the host can easily load a modified container. There is a need for another entity to check that the container is genuine and running in a secure environment that respects the correct rules.

Container steps:

* Create a key pair
* Fetch an attestation report with REPORT_DATA == hash of public part of the key pair
* Pass the attestation report and supporting documents to the relying party

Relying party steps:

* Check that the attestation report is genuine and produced by real AMD SNP hardware by checking it is correctly signed, using the platform certificates in `host-amd-cert-base64`.
* Check that the TEE is not in debug mode by inspecting the attestation report table 8.
* Check that the Microsoft signed UVM reference info is genuine by checking the issuer and feed fields match the well known Confidential ACI values above and that the document is well formed.
* Check that the launch measurement in the UVM reference info matches the launch measurement in the attestation report.
* Check that the UVM SVN `x-ms-sevsnpvm-guestsvn` or `x-ms-sevsnpvm-guestsvn-int` is at least the expected value. Use the string or integer version depending on how the relying party manage range checking.
* Check that the HOST_DATA (sha256 over the security policy) is as expected. This is a customer specific value, for example it may be part of a mHSM key release policy.
* Check that the attestation report (table 22 in https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/56860.pdf) field VMPL is not 0xFFFFFFFF which indicates a report generated by the host. Confidential ACI Linux reports currently come from VMPL 0.
* Given all the above pass, encrypt the secret with the public part of the key from REPORT_DATA and return it to the container.
